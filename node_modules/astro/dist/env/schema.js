import { z } from "zod";
import { PUBLIC_PREFIX } from "./constants.js";
const StringSchema = z.object({
  type: z.literal("string"),
  optional: z.boolean().optional(),
  default: z.string().optional()
});
const NumberSchema = z.object({
  type: z.literal("number"),
  optional: z.boolean().optional(),
  default: z.number().optional()
});
const BooleanSchema = z.object({
  type: z.literal("boolean"),
  optional: z.boolean().optional(),
  default: z.boolean().optional()
});
const EnvFieldType = z.discriminatedUnion("type", [StringSchema, NumberSchema, BooleanSchema]);
const PublicClientEnvFieldMetadata = z.object({
  context: z.literal("client"),
  access: z.literal("public")
});
const PublicServerEnvFieldMetadata = z.object({
  context: z.literal("server"),
  access: z.literal("public")
});
const SecretServerEnvFieldMetadata = z.object({
  context: z.literal("server"),
  access: z.literal("secret")
});
const KEY_REGEX = /^[A-Z_]+$/;
const EnvSchema = z.record(
  z.string().regex(KEY_REGEX, {
    message: "A valid variable name can only contain uppercase letters and underscores."
  }),
  z.intersection(
    z.union([
      PublicClientEnvFieldMetadata,
      PublicServerEnvFieldMetadata,
      SecretServerEnvFieldMetadata
    ]),
    EnvFieldType
  )
).superRefine((schema, ctx) => {
  for (const [key, value] of Object.entries(schema)) {
    if (key.startsWith(PUBLIC_PREFIX) && value.access !== "public") {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `An environment variable whose name is prefixed by "${PUBLIC_PREFIX}" must be public.`
      });
    }
    if (value.access === "public" && !key.startsWith(PUBLIC_PREFIX)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `An environment variable that is public must have a name prefixed by "${PUBLIC_PREFIX}".`
      });
    }
  }
});
const StringField = z.intersection(
  z.union([
    PublicClientEnvFieldMetadata,
    PublicServerEnvFieldMetadata,
    SecretServerEnvFieldMetadata
  ]),
  StringSchema
);
const StringFieldInput = z.intersection(
  z.union([
    PublicClientEnvFieldMetadata,
    PublicServerEnvFieldMetadata,
    SecretServerEnvFieldMetadata
  ]),
  StringSchema.omit({ type: true })
);
const NumberField = z.intersection(
  z.union([
    PublicClientEnvFieldMetadata,
    PublicServerEnvFieldMetadata,
    SecretServerEnvFieldMetadata
  ]),
  NumberSchema
);
const NumberFieldInput = z.intersection(
  z.union([
    PublicClientEnvFieldMetadata,
    PublicServerEnvFieldMetadata,
    SecretServerEnvFieldMetadata
  ]),
  NumberSchema.omit({ type: true })
);
const BooleanField = z.intersection(
  z.union([
    PublicClientEnvFieldMetadata,
    PublicServerEnvFieldMetadata,
    SecretServerEnvFieldMetadata
  ]),
  BooleanSchema
);
const BooleanFieldInput = z.intersection(
  z.union([
    PublicClientEnvFieldMetadata,
    PublicServerEnvFieldMetadata,
    SecretServerEnvFieldMetadata
  ]),
  BooleanSchema.omit({ type: true })
);
export {
  BooleanFieldInput,
  EnvSchema,
  NumberFieldInput,
  StringFieldInput
};
